name: Fullstack CI/CD (Quasar, .NET, Docker, Deploy)

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  # Paths
  QUASAR_ROOT: frontend 
  DOTNET_ROOT: backend
  # Versions
  NODE_VERSION: '20.x'
  DOTNET_VERSION: '8.0.x' 
  
  # Docker Variables
  FULL_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/${{ github.event.repository.name }}
  CONTAINER_NAME: user-vault-app

jobs:
  build:
    name: Build & Package App
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Node Modules
        id: cache-npm
        uses: actions/cache@v4
        with:
          path: ${{ env.QUASAR_ROOT }}/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles(format('{0}/package-lock.json', env.QUASAR_ROOT)) }}
          restore-keys: |
            ${{ runner.os }}-node-
    
      - name: Install Quasar Dependencies
        if: steps.cache-npm.outputs.cache-hit != 'true'
        run: npm ci
        working-directory: ${{ env.QUASAR_ROOT }}
  
      - name: Install Quasar CLI
        run: npm install -g @quasar/cli
  
      - name: Build Quasar App and Copy to .NET
        run: quasar build -m spa --output-path ../${{ env.DOTNET_ROOT }}/wwwroot/dist
        working-directory: ${{ env.QUASAR_ROOT }}

      - name: Set up .NET SDK ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore, Build, and Publish .NET App
        run: |
          dotnet restore *.sln
          dotnet build *.sln --configuration Release --no-restore
          # Publishing the solution will automatically find the executable project (usually the web project).
          dotnet publish *.sln --configuration Release --no-build --output ${{ github.workspace }}/deployment-package
        working-directory: ${{ env.DOTNET_ROOT }}
      
      - name: Upload Deployment Package Artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: ${{ github.workspace }}/deployment-package
          retention-days: 7


  docker_build_and_push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Deployment Package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: deployment-package
          
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: . 
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.FULL_IMAGE_NAME }}:${{ github.sha }}
            ${{ env.FULL_IMAGE_NAME }}:latest


  deploy_to_self_hosted:
    name: Deploy via Self-Hosted Runner
    runs-on: [self-hosted, linux] 
    needs: docker_build_and_push
    environment: Production

    steps:
      - name: Login to Docker Hub (on self-hosted runner)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Pull Latest Docker Image
        run: |
          docker pull ${{ env.FULL_IMAGE_NAME }}:latest

      - name: Stop and Remove Old Container
        run: |
          # Use '|| true' to prevent the step from failing if the container doesn't exist
          if [ "$(docker ps -a -q -f name=${{ env.CONTAINER_NAME }})" ]; then
            echo "Stopping and removing existing container..."
            docker stop ${{ env.CONTAINER_NAME }} || true
            docker rm ${{ env.CONTAINER_NAME }} || true
          fi

      - name: Run New Container
        run: |
          echo "Starting new container using ${{ env.FULL_IMAGE_NAME }}:latest"
          # -d runs in detached mode, -p 3003:8080 maps external port 80 to container port 3003
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p 3003:8080 \
            ${{ env.FULL_IMAGE_NAME }}:latest
          echo "Deployment successful."
